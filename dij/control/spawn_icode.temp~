/*TODO remove references to standard libraries*/
#include <stdlib.h>
/*iCode interface to implement the spawn method of the fgraph*/

struct _channel_send_machine
   {
   struct iProcess *process;
   struct iChannel *channel;
   }

struct _channel_receive_machine
   {
   struct iProcess *process;
   struct iChannel *channel;
   struct iChannelClient *client;
   }

void channel_receive_iMachine_destroy(struct iMachine *self)
   {
   struct _channel_receive_machine *M = (struct _channel_receive_machine *)(self->M);
   M->channel->abandon(M->channel, M->client);
   free(self->M);
   free(self);
   }

struct iException *channel_receive_iMachine_run(struct iMachine *self)
   {
   struct _channel_receive_machine *M = (struct _channel_receive_machine *)(self->M);
   }

void channel_send_iMachine_destroy(struct iMachine *self)
   {
   free(self->M);
   free(self);
   }

struct iException *channel_send_iMachine_run(struct iMachine *self)
   {
   /*gathers up all the anonymous parameters and sends them on the channel*/
   struct _channel_send_machine *M = (struct _channel_send_machine *)(self->M);
   int *memory;
   int i;
   struct object_type **types;
   struct _stack_member *message, *sploop, *sploop_last;
   M->process->get_memory(M->process, &memory, &types, 0 );
   message = 0;
   i = M->context->num_parameters + M->context->num_locals + M->context->num_returns;
   while
      ( 
      i < 
         M->context->num_parameters + 
         M->context->num_locals +
         M->context->num_returns +
         M->context->num_anonymous 
      )
      {
      sploop = (struct _stack_member *)malloc(sizeof(struct _stack_member));
      sploop->value.value = memory[i];
      sploop->value.type = types[i];
      sploop->next = 0;
      i++;
      if( message == 0 ) { message = sploop; sploop_last = message; } 
      else { sploop_last->next = sploop; }
      }
   M->channel->send(M->channel, message);
   /*TODO who cleans up message here?*/
   return 0;
   }

struct iMachine *channel_send_iCode_new
   ( 
   struct iCode *self,
   struct _fcontext *context,
   struct iProcess *process,
   struct iFGraph *fgraph
   )
   {
   struct iMachine *ret = (struct iMachine *)malloc(sizeof(struct iMachine *));
   struct _channel_send_machine *M 
      = (struct _channel_send_machine *)malloc(sizeof(struct _channel_send_machine));
   M->channel = (struct iChannel *)(self->C);
   M->process = process;
   ret->M = M;
   ret->run = channel_send_iMachine_run;
   ret->destroy = channel_send_iMachine_destroy;
   return ret;
   }

struct iMachine *channel_receive_iCode_new
   ( 
   struct iCode *self,
   struct _fcontext *context,
   struct iProcess *process,
   struct iFGraph *fgraph
   )
   {
   struct iMachine *ret = (struct iMachine *)malloc(sizeof(struct iMachine *));
   struct _channel_receive_machine *M
      = (struct _channel_receive_machine *)malloc(sizeof(struct _channel_receive_machine));
   M->process = process;
   M->channel = self->C;
   M->client = get_process_client(process);
   ret->M = M;
   ret->run = channel_receive_iMachine_run;
   ret->destroy = channel_receive_iMachine_destroy;
   return ret;
   }

struct iCode *get_channel_send( iChannel *c )
   {
   struct iCode *ret = (struct iCode *)malloc(sizeof(struct iCode));
   ret->C = c;
   ret->new = channel_send_iCode_new;
   return ret;
   }

struct iCode *get_channel_receive( iChannel *c )
   {
   struct iCode *ret = (struct iCode *)malloc(sizeof(struct iCode));
   ret->C = c;
   ret->new = channel_receive_iCode_new;
   return ret;
   }
